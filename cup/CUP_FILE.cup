/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import ast.*;

/*************/
/* PARSER CODE */
/*************/
parser code 
{:
	public Lexer lexer;
	public java.io.PrintWriter fileWriter;
	public boolean errorLexer = false;

	public Parser(Lexer lexer, java.io.PrintWriter fileWriter)
	{
		super(lexer);
		this.lexer = lexer;
		this.fileWriter = fileWriter;
	}

	public void report_error(String message, Object info)
	{
		System.out.print("ERROR >> ");		
		System.out.print("[");
		System.out.print(lexer.getLine());
		System.out.print(":");
		System.out.print(lexer.getTokenStartPosition());
		System.out.print("] ");
		System.out.println();
		
		if (errorLexer)
		{
			fileWriter.print("ERROR");
		}
		else
		{
			fileWriter.print("ERROR(");
			fileWriter.print(lexer.getLine());
			fileWriter.print(")");
		}
		fileWriter.close();
		System.exit(0);
	}
:}

/************************/
/* CUSTOM SCAN METHOD   */
/************************/
scan with
{:
	Symbol s = lexer.next_token();
	errorLexer = (s.sym == TokenNames.ERROR);
	System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getTokenStartPosition());
	System.out.print("] ");
	System.out.print(TokenNames.terminalNames[s.sym]);
	if (s.value != null)
	{
		System.out.print("( ");
		System.out.print(s.value);
		System.out.print(" )");
	}
	System.out.print("\n");
	return s; 
:};

/*************/
/* TERMINALS */
/*************/
terminal IF, ELSE, WHILE, RETURN, CLASS, EXTENDS, NEW, ARRAY, NIL;
terminal EQ, LT, GT, PLUS, MINUS, TIMES, DIVIDE;
terminal DOT, COMMA, SEMICOLON, ASSIGN;
terminal LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;

terminal TYPE_INT, TYPE_STRING, TYPE_VOID;
terminal ERROR;

terminal Integer INT;
terminal String STRING;
terminal String ID;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AstDecList      program;

non terminal AstDec          dec;
non terminal AstDecVar       decVar;
non terminal AstDecFunc      decFunc;
non terminal AstDecClass     decClass;
non terminal AstDecArrayTypedef arrayTypedef;

non terminal AstCFieldList   cFieldList;
non terminal AstCField       cField;

non terminal String          type;

non terminal AstExpVar       var;

non terminal AstExp          exp;
non terminal AstExpCall      callExp;

non terminal AstExpList      expList;

non terminal AstStmt         stmt;
non terminal AstStmtList     stmtList;

non terminal AstTypeName     param;
non terminal AstTypeNameList paramList;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
/* Precedence from lowest to highest (per Table 1 in spec) */
/* 1. := assign - handled by grammar structure, not precedence */
/* 2. = equals */
precedence left EQ;
/* 3. <, > comparison */
precedence left LT, GT;
/* 4. +, - addition/subtraction */
precedence left PLUS, MINUS;
/* 5. *, / multiplication/division */
precedence left TIMES, DIVIDE;
/* Unary minus needs higher precedence than binary operators */
precedence left UMINUS;

/****************/
/* START SYMBOL */
/****************/
start with program;

/********************/
/* DERIVATION RULES */
/********************/

/************/
/* PROGRAM  */
/************/
program ::= dec:d program:p   {: RESULT = new AstDecList(d, p); :}
          | dec:d             {: RESULT = new AstDecList(d, null); :}
          ;

/*********/
/* DEC   */
/*********/
dec ::= decVar:v              {: RESULT = v; :}
     | decFunc:f              {: RESULT = f; :}
     | decClass:c             {: RESULT = c; :}
     | arrayTypedef:a         {: RESULT = a; :}
     ;

/****************/
/* VAR DEC      */
/****************/
decVar ::= type:t ID:name SEMICOLON               
            {: RESULT = new AstDecVar(lexer.getLine(), t, name, null); :}
         | type:t ID:name ASSIGN exp:e SEMICOLON  
            {: RESULT = new AstDecVar(lexer.getLine(), t, name, e); :}
         ;

/****************/
/* FUNC PARAMS  */
/****************/
param ::= type:t ID:name
          {: RESULT = new AstTypeName(t, name); :}
          ;

paramList ::= param:p
              {: RESULT = new AstTypeNameList(p, null); :}
            | param:p COMMA paramList:rest
              {: RESULT = new AstTypeNameList(p, rest); :}
            ;

/****************/
/* FUNC DEC     */
/****************/
decFunc ::=
      type:t ID:name LPAREN RPAREN
      LBRACE stmtList:body RBRACE
      {: RESULT = new AstDecFunc(lexer.getLine(), t, name, null, body); :}

    | type:t ID:name LPAREN paramList:params RPAREN
      LBRACE stmtList:body RBRACE
      {: RESULT = new AstDecFunc(lexer.getLine(), t, name, params, body); :}
    ;

/*****************/
/* CLASS DEC     */
/*****************/
decClass ::= CLASS ID:name LBRACE cFieldList:f RBRACE
             {: RESULT = new AstDecClass(lexer.getLine(), name, null, f); :}
           | CLASS ID:name EXTENDS ID:parent 
             LBRACE cFieldList:f RBRACE
             {: RESULT = new AstDecClass(lexer.getLine(), name, parent, f); :}
           ;

/*************************/
/* ARRAY TYPEDEF DEC     */
/*************************/
arrayTypedef ::= ARRAY ID:name EQ type:t LBRACK RBRACK SEMICOLON
                 {: RESULT = new AstDecArrayTypedef(lexer.getLine(), name, t); :}
               ;

/***********************/
/* CLASS FIELD LIST    */
/***********************/
cFieldList ::= cField:f cFieldList:rest
               {: RESULT = new AstCFieldList(f, rest); :}
             | cField:f
               {: RESULT = new AstCFieldList(f, null); :}
             ;

cField ::= type:t ID:name SEMICOLON     
           {: RESULT = new AstCFieldVar(new AstDecVar(lexer.getLine(), t, name, null)); :}
         | type:t ID:name ASSIGN exp:e SEMICOLON
           {: RESULT = new AstCFieldVar(new AstDecVar(lexer.getLine(), t, name, e)); :}
         | decFunc:f
           {: RESULT = new AstCFieldFunc(f); :}
         ;

/************/
/* TYPE     */
/************/
type ::= TYPE_INT        {: RESULT = "int"; :}
       | TYPE_STRING     {: RESULT = "string"; :}
       | TYPE_VOID       {: RESULT = "void"; :}
       | ID:name         {: RESULT = name; :}
       ;

/************/
/* VAR      */
/************/
var ::= ID:name                          {: RESULT = new AstExpVarSimple(name); :}
      | var:v DOT ID:fieldName           {: RESULT = new AstExpVarField(v, fieldName); :}
      | var:v LBRACK exp:e RBRACK        {: RESULT = new AstExpVarSubscript(v, e); :}
      ;

/************/
/* CALL EXPR*/
/************/
callExp ::= 
          ID:name LPAREN RPAREN
            {: RESULT = new AstExpCall(null, name, null); :}
          
        | ID:name LPAREN expList:args RPAREN
            {: RESULT = new AstExpCall(null, name, args); :}
          
        | var:v DOT ID:name LPAREN RPAREN
            {: RESULT = new AstExpCall(v, name, null); :}
          
        | var:v DOT ID:name LPAREN expList:args RPAREN
            {: RESULT = new AstExpCall(v, name, args); :}
          ;

/************/
/* EXP LIST */
/************/
expList ::= exp:e                        {: RESULT = new AstExpList(e, null); :}
          | exp:e COMMA expList:rest     {: RESULT = new AstExpList(e, rest); :}
          ;

/************/
/* EXP      */
/************/
exp ::= INT:i                              {: RESULT = new AstExpInt(i); :}
      | STRING:s                           {: RESULT = new AstExpString(s); :}
      | NIL                                {: RESULT = new AstExpNil(); :}
      | var:v                              {: RESULT = v; :}
      | exp:e1 PLUS exp:e2                 {: RESULT = new AstExpBinop(e1, e2, 0); :}
      | exp:e1 MINUS exp:e2                {: RESULT = new AstExpBinop(e1, e2, 1); :}
      | exp:e1 TIMES exp:e2                {: RESULT = new AstExpBinop(e1, e2, 2); :}
      | exp:e1 DIVIDE exp:e2               {: RESULT = new AstExpBinop(e1, e2, 3); :}
      | exp:e1 LT exp:e2                   {: RESULT = new AstExpBinop(e1, e2, 4); :}
      | exp:e1 GT exp:e2                   {: RESULT = new AstExpBinop(e1, e2, 5); :}
      | exp:e1 EQ exp:e2                   {: RESULT = new AstExpBinop(e1, e2, 6); :}
      | MINUS exp:e                        {: RESULT = new AstExpUnaryMinus(e); :} %prec UMINUS
      | LPAREN exp:e RPAREN                {: RESULT = new AstExpParen(e); :}
      | callExp:c                          {: RESULT = c; :}
      | NEW type:t                         {: RESULT = new AstExpNewClass(t); :}
      | NEW type:t LBRACK exp:size RBRACK  {: RESULT = new AstExpNewArray(t, size); :}
      ;

/****************/
/* STATEMENT    */
/****************/
stmt ::=
         type:t ID:name SEMICOLON
            {: RESULT = new AstStmtDecVar(new AstDecVar(lexer.getLine(), t, name, null)); :}

       | type:t ID:name ASSIGN exp:e SEMICOLON
            {: RESULT = new AstStmtDecVar(new AstDecVar(lexer.getLine(), t, name, e)); :}

       | var:v ASSIGN exp:e SEMICOLON
         {: RESULT = new AstStmtAssign(v, e); :}

       | RETURN exp:e SEMICOLON
         {: RESULT = new AstStmtReturn(e); :}

       | RETURN SEMICOLON
         {: RESULT = new AstStmtReturn(null); :}

       | IF LPAREN exp:c RPAREN 
         LBRACE stmtList:body RBRACE
         {: RESULT = new AstStmtIf(c, body, null); :}

       | IF LPAREN exp:c RPAREN 
         LBRACE stmtList:thenBody RBRACE 
         ELSE LBRACE stmtList:elseBody RBRACE
         {: RESULT = new AstStmtIf(c, thenBody, elseBody); :}

       | WHILE LPAREN exp:c RPAREN 
         LBRACE stmtList:body RBRACE
         {: RESULT = new AstStmtWhile(c, body); :}

       | callExp:c SEMICOLON
         {: RESULT = new AstStmtCall(c); :}
       ;

/*****************/
/* STMT LIST     */
/*****************/
stmtList ::= stmt:s stmtList:rest    {: RESULT = new AstStmtList(s, rest); :}
           | stmt:s                  {: RESULT = new AstStmtList(s, null); :}
           ;
